@article{Erdos1960On,
    author = {Erd\"{o}s, P. and R\'{e}nyi, A.},
    citeulike-article-id = {1666220},
    citeulike-linkout-0 = {https://www.renyi.hu/\~{}p_erdos/1960-10.pdf},
    journal = {Publ. Math. Inst. Hung. Acad. Sci},
    keywords = {graphs, random, review},
    pages = {17--61},
    posted-at = {2014-05-19 10:19:50},
    priority = {1},
    title = {{On the evolution of random graphs}},
    url = {https://www.renyi.hu/\~p_erdos/1960-10.pdf},
    volume = {5},
    year = {1960}
}

@article{Bollobas1984Evolution,
    abstract = {According to a fundamental result of Erd\"{o}s and R\'{e}nyi, the structure of a random graph \$G_M\$ changes suddenly when \$M \sim n/2:\$ if \$M = \lfloor cn \rfloor\$ and \$c < \frac{1}{2}\$ then a.e. random graph of order \$n\$ and since \$M\$ is such that its largest component has \$O(\log n)\$ vertices, but for \$c > \frac{1}{2} a.e. \$G_M\$ has a giant component: a component of order \$(1 - \alpha_c + o(1))n\$ where \$\alpha_c < 1\$. The aim of this paper is to examine in detail the structure of a random graph \$G_M\$ when \$M\$ is close to \$n/2\$. Among others it is proved that if \$M = n/2 + s, s = o(n)\$ and \$s \geq (\log n)^{1/2}n^{2/3}\$ then the giant component has \$(4 + o(1))s\$ vertices. Furthermore, rather precise estimates are given for the order of the \$r\$th largest component for every fixed \$r\$.},
    author = {Bollobas, Bela},
    citeulike-article-id = {4596187},
    citeulike-linkout-0 = {http://dx.doi.org/10.2307/1999405},
    citeulike-linkout-1 = {http://www.jstor.org/stable/1999405},
    doi = {10.2307/1999405},
    issn = {00029947},
    journal = {Transactions of the American Mathematical Society},
    keywords = {graphs, random, review},
    month = nov,
    number = {1},
    pages = {257--274},
    posted-at = {2014-05-19 10:18:11},
    priority = {1},
    publisher = {American Mathematical Society},
    title = {{The Evolution of Random Graphs}},
    url = {http://dx.doi.org/10.2307/1999405},
    volume = {286},
    year = {1984}
}

@article{Hesselink2001Concurrent,
    author = {Hesselink, Wim H. and Meijster, Arnold and Bron, Coenraad},
    citeulike-article-id = {13156334},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/s0167-6423(01)00007-7},
    doi = {10.1016/s0167-6423(01)00007-7},
    issn = {01676423},
    journal = {Science of Computer Programming},
    keywords = {computer-vision, morphology, parallel-programming, segmentation, union-find},
    month = oct,
    number = {2},
    pages = {173--194},
    posted-at = {2014-05-01 13:43:47},
    priority = {5},
    title = {{Concurrent determination of connected components}},
    url = {http://dx.doi.org/10.1016/s0167-6423(01)00007-7},
    volume = {41},
    year = {2001}
}

@book{Roscoe1997Theory,
    abstract = {{From the Publisher:Since the introduction of Hoares' Communicating Sequential Processes notation, powerful new tools have transformed CSP into a practical way of describing industrial-sized problems. This book gives you the fundamental grasp of CSP concepts you'll need to take advantage of those tools.Part I provides a detailed foundation for working with CSP, using as little mathematics as possible. It introduces the ideas behind operational, denotational and algebraic models of CSP. Parts II and III go into greater detail about theory and practice. Topics include: parallel operators, hiding and renaming, piping and enslavement, buffers and communication, termination and sequencing, and semantic theory. Three detailed practical case studies are also presented.For anyone interested in modeling sequential processes.}},
    address = {Upper Saddle River, NJ, USA},
    author = {Roscoe, A. W. and Hoare, C. A. R. and Bird, Richard},
    citeulike-article-id = {1010001},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=550448},
    isbn = {0136744095},
    keywords = {concurrency-verification, csp, formal-methods, parallel-programming},
    posted-at = {2014-04-25 13:36:03},
    priority = {1},
    publisher = {Prentice Hall PTR},
    title = {{The Theory and Practice of Concurrency}},
    url = {http://portal.acm.org/citation.cfm?id=550448},
    year = {1997}
}

@article{Hoare1978Communicating,
    abstract = {{This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.}},
    address = {New York, NY, USA},
    author = {Hoare, C. A. R.},
    citeulike-article-id = {785872},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=359585},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/359576.359585},
    doi = {10.1145/359576.359585},
    issn = {0001-0782},
    journal = {Commun. ACM},
    keywords = {concurrency-verification, csp, formal-methods, parallel-programming},
    month = aug,
    number = {8},
    pages = {666--677},
    posted-at = {2014-04-25 13:32:18},
    priority = {2},
    publisher = {ACM},
    title = {{Communicating Sequential Processes}},
    url = {http://dx.doi.org/10.1145/359576.359585},
    volume = {21},
    year = {1978}
}

@book{Kleinberg2006Algorithm,
    abstract = {{Algorithm Design introduces algorithms by looking at the real-world problems that motivate them. The book teaches a range of design and analysis techniques for problems that arise in computing applications. The text encourages an understanding of the algorithm design process and an appreciation of the role of algorithms in the broader field of computer science.}},
    author = {Kleinberg, Jon and Tardos, \'{E}va},
    citeulike-article-id = {578377},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321295358},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0321295358},
    citeulike-linkout-10 = {http://www.worldcat.org/oclc/845840753},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0321295358},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0321295358},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0321295358/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321295358},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0321295358},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0321295358},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0321295358\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0321295358},
    day = {26},
    edition = {United States ed},
    howpublished = {Hardcover},
    isbn = {0321295358},
    keywords = {algorithms, review},
    month = mar,
    posted-at = {2014-04-24 11:24:35},
    priority = {0},
    publisher = {Pearson, Addison-Wesley},
    title = {{Algorithm Design}},
    url = {http://www.worldcat.org/isbn/0321295358},
    year = {2006}
}

@misc{Biermann2013Morphological,
    author = {Biermann, Florian},
    citeulike-article-id = {13145801},
    citeulike-linkout-0 = {http://itu.dk/people/fbie/morphological_segmentation_malaria.pdf},
    institution = {IT University of Copenhagen},
    keywords = {malaria, morphology, unpublished},
    month = nov,
    note = {Semester project report, IT University of Copenhagen. Accessed 23.04.2014},
    posted-at = {2014-04-23 14:58:23},
    priority = {0},
    title = {{Morphological Segmentation of Blood Images for Automated Malaria Diagnosis}},
    url = {http://itu.dk/people/fbie/morphological_segmentation_malaria.pdf},
    year = {2013}
}

@article{MohanaRao2001Areagranulometry,
    author = {Mohana Rao, K. N. R. and Dempster, A. G.},
    citeulike-article-id = {12556142},
    citeulike-linkout-0 = {http://dx.doi.org/10.1049/el:20010635},
    doi = {10.1049/el:20010635},
    issn = {00135194},
    journal = {Electronics Letters},
    keywords = {granulometry, morphology},
    number = {15},
    pages = {950+},
    posted-at = {2014-04-23 13:11:27},
    priority = {0},
    title = {{Area-granulometry: an improved estimator of size distribution of image objects}},
    url = {http://dx.doi.org/10.1049/el:20010635},
    volume = {37},
    year = {2001}
}

@article{Tek2010Parasite,
    abstract = {{This paper investigates automated detection and identification of malaria parasites in images of Giemsa-stained thin blood film specimens. The Giemsa stain highlights not only the malaria parasites but also the white blood cells, platelets, and artefacts. We propose a complete framework to extract these stained structures, determine whether they are parasites, and identify the infecting species and life-cycle stages. We investigate species and life-cycle-stage identification as multi-class classification problems in which we compare three different classification schemes and empirically show that the detection, species, and life-cycle-stage tasks can be performed in a joint classification as well as an extension to binary detection. The proposed binary parasite detector can operate at 0.1\%0.1\% parasitemia without any false detections and with less than 10 false detections at levels as low as 0.01\%0.01\%.}},
    author = {Tek, F. Boray and Dempster, Andrew G. and Kale, \.{I}zzet},
    citeulike-article-id = {5665411},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/j.cviu.2009.08.003},
    day = {24},
    doi = {10.1016/j.cviu.2009.08.003},
    issn = {10773142},
    journal = {Computer Vision and Image Understanding},
    keywords = {malaria, morphology},
    month = jan,
    number = {1},
    pages = {21--32},
    posted-at = {2014-04-23 13:07:44},
    priority = {0},
    title = {{Parasite detection and identification for automated thin blood film malaria diagnosis}},
    url = {http://dx.doi.org/10.1016/j.cviu.2009.08.003},
    volume = {114},
    year = {2010}
}

@misc{PerfWiki,
    citeulike-article-id = {13141391},
    citeulike-linkout-0 = {https://perf.wiki.kernel.org/index.php/Main_Page},
    keywords = {linux-kernel, website},
    note = {Accessed: 18.04.2014},
    posted-at = {2014-04-18 10:41:23},
    priority = {0},
    title = {{perf: Linux profiling with performance counters}},
    url = {https://perf.wiki.kernel.org/index.php/Main_Page}
}

@misc{Sestoft2013Microbenchmarks,
    address = {Rued Langgaards Vej , 2300 Copenhagen},
    author = {Sestoft, Peter},
    citeulike-article-id = {13140844},
    citeulike-linkout-0 = {https://www.itu.dk/people/sestoft/papers/benchmarking.pdf},
    institution = {IT University of Copenhagen},
    keywords = {java, microbenchmarks, performance},
    month = sep,
    note = {Lecture Notes, IT University of Copenhagen. Accessed 17.04.2014},
    organization = {IT University of Copenhagen},
    posted-at = {2014-04-17 14:49:58},
    priority = {0},
    school = {IT University of Copenhagen},
    title = {{Microbenchmarks in Java and C\#}},
    url = {https://www.itu.dk/people/sestoft/papers/benchmarking.pdf},
    year = {2013}
}

@incollection{Khurshid2003Generalized,
    abstract = {{Modern software systems, which often are concurrent and manipulate complex data structures must be extremely reliable. We present a novel framework based on symbolic execution, for automated checking of such systems. We provide a two-fold generalization of traditional symbolic execution based approaches. First, we define a source to source translation to instrument a program, which enables standard model checkers to perform symbolic execution of the program. Second, we give a novel symbolic execution algorithm that handles dynamically allocated structures (e.g., lists and trees), method preconditions (e.g., acyclicity), data (e.g., integers and strings) and concurrency. The program instrumentation enables a model checker to automatically explore different program heap configurations and manipulate logical formulae on program data (using a decision procedure). We illustrate two applications of our framework: checking correctness of multi-threaded programs that take inputs from unbounded domains with complex structure and generation of non-isomorphic test inputs that satisfy a testing criterion. Our implementation for Java uses the Java PathFinder model checker.}},
    address = {Berlin, Heidelberg},
    author = {Khurshid, Sarfraz and P\u{a}s\u{a}reanu, Corina S. and Visser, Willem},
    booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
    chapter = {40},
    citeulike-article-id = {3037858},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-36577-x_40},
    citeulike-linkout-1 = {http://www.springerlink.com/content/pllk4effd3vrec7l},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/3-540-36577-X_40},
    day = {28},
    doi = {10.1007/3-540-36577-x_40},
    editor = {Garavel, Hubert and Hatcliff, John},
    isbn = {978-3-540-00898-9},
    journal = {Tools and Algorithms for the Construction and Analysis of Systems},
    keywords = {formal-methods, jpf, model-checking, symbolic},
    month = feb,
    pages = {553--568},
    posted-at = {2014-04-16 11:52:07},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Generalized Symbolic Execution for Model Checking and Testing}},
    url = {http://dx.doi.org/10.1007/3-540-36577-x_40},
    volume = {2619},
    year = {2003}
}

@article{Alistarh2013Are,
    author = {Alistarh, D. and Censor-Hillel, K. and Shavit, N.},
    citeulike-article-id = {13119083},
    citeulike-linkout-0 = {http://arxiv.org/pdf/1311.3200.pdf},
    journal = {ArXiv e-prints},
    keywords = {parallel-programming, performance},
    month = nov,
    posted-at = {2014-03-28 11:43:13},
    priority = {4},
    title = {{Are Lock-Free Concurrent Algorithms Practically Wait-Free?}},
    url = {http://arxiv.org/pdf/1311.3200.pdf},
    year = {2013}
}

@article{Visser2004Test,
    abstract = {{We show how model checking and symbolic execution can be used to generate test inputs to achieve structural coverage of code that manipulates complex data structures. We focus on obtaining branch-coverage during unit testing of some of the core methods of the red-black tree implementation in the Java TreeMap library, using the Java PathFinder model checker. Three different test generation techniques will be introduced and compared, namely, straight model checking of the code, model checking used in a black-box fashion to generate all inputs up to a fixed size, and lastly, model checking used during white-box test input generation. The main contribution of this work is to show how efficient white-box test input generation can be done for code manipulating complex data, taking into account complex method preconditions.}},
    address = {New York, NY, USA},
    author = {Visser, Willem and P\v{a}s\v{a}reanu, Corina S. and Khurshid, Sarfraz},
    citeulike-article-id = {80857},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1013886.1007526},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1013886.1007526},
    doi = {10.1145/1013886.1007526},
    isbn = {1581138202},
    issn = {0163-5948},
    journal = {SIGSOFT Softw. Eng. Notes},
    keywords = {jpf, model-checking},
    month = jul,
    number = {4},
    pages = {97--107},
    posted-at = {2014-03-18 16:19:13},
    priority = {5},
    publisher = {ACM},
    title = {{Test Input Generation with Java PathFinder}},
    url = {http://dx.doi.org/10.1145/1013886.1007526},
    volume = {29},
    year = {2004}
}

@article{Visser2003Model,
    abstract = {{The majority of work carried out in the formal methods community throughout the last three decades has (for good reasons) been devoted to special languages designed to make it easier to experiment with mechanized formal methods such as theorem provers, proof checkers and model checkers. In this paper we will attempt to give convincing arguments for why we believe it is time for the formal methods community to shift some of its attention towards the analysis of programs written in modern programming languages. In keeping with this philosophy we have developed a verification and testing environment for Java, called Java PathFinder (JPF), which integrates model checking, program analysis and testing. Part of this work has consisted of building a new Java Virtual Machine that interprets Java bytecode. JPF uses state compression to handle big states, and partial order and symmetry reduction, slicing, abstraction, and runtime analysis techniques to reduce the state space. JPF has been applied to a real-time avionics operating system developed at Honeywell, illustrating an intricate error, and to a model of a spacecraft controller, illustrating the combination of abstraction, runtime analysis, and slicing with model checking.}},
    address = {Hingham, MA, USA},
    author = {Visser, Willem and Havelund, Klaus and Brat, Guillaume and Park, SeungJoon and Lerda, Flavio},
    booktitle = {Automated Software Engineering},
    citeulike-article-id = {1188784},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=641186},
    citeulike-linkout-1 = {http://dx.doi.org/10.1023/a:1022920129859},
    citeulike-linkout-2 = {http://link.springer.com/article/10.1023/A:1022920129859},
    day = {1},
    doi = {10.1023/a:1022920129859},
    issn = {0928-8910},
    journal = {Automated Software Engg.},
    keywords = {concurrency-verification, jpf, model-checking},
    month = apr,
    number = {2},
    pages = {203--232},
    posted-at = {2014-03-18 14:51:02},
    priority = {4},
    publisher = {Kluwer Academic Publishers},
    title = {{Model Checking Programs}},
    url = {http://dx.doi.org/10.1023/a:1022920129859},
    volume = {10},
    year = {2003}
}

@inproceedings{Suckling1994Mammographic,
    author = {Suckling, J. and Parker, J. and Dance, D. R. and Astley, S. and Hutt, I. and Boggis, C. and Ricketts, I. and Stamatakis, E. and Cerneaz, N. and Kok, S. L. and Taylor, P. and Betal, D. and Savage, J.},
    booktitle = {Excerta Medica},
    citeulike-article-id = {13094569},
    citeulike-linkout-0 = {http://discovery.ucl.ac.uk/102193/},
    editor = {Gale, A. G. and Astley, S. M. and Dance, D. R. and Cairns, A. Y.},
    journal = {2nd International Workshop on Digital Mammography},
    keywords = {computer-vision, database},
    location = {Amsterdam},
    month = jul,
    pages = {375--378},
    posted-at = {2014-03-05 14:08:23},
    priority = {1},
    series = {International congress series},
    title = {{The Mammographic Image Analysis Society digital mammogram database}},
    url = {http://discovery.ucl.ac.uk/102193/},
    volume = {1069},
    year = {1994}
}

@article{Edelstein2002Multithreaded,
    author = {Edelstein, O. and Farchi, E. and Nir, Y. and Ratsaby, G. and Ur, S.},
    citeulike-article-id = {13093451},
    citeulike-linkout-0 = {http://dx.doi.org/10.1147/sj.411.0111},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5386903},
    doi = {10.1147/sj.411.0111},
    institution = {IBM Research Division, Haifa Research Laboratory, MATAM, 31905, Israel},
    issn = {0018-8670},
    journal = {IBM Systems Journal},
    keywords = {concurrency-verification, parallel-programming},
    number = {1},
    pages = {111--125},
    posted-at = {2014-03-05 09:39:28},
    priority = {4},
    publisher = {IBM},
    title = {{Multithreaded Java program test generation}},
    url = {http://dx.doi.org/10.1147/sj.411.0111},
    volume = {41},
    year = {2002}
}

@book{Szeliski2011Computer,
    address = {London},
    author = {Szeliski, Richard},
    citeulike-article-id = {10710867},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-1-84882-935-0},
    citeulike-linkout-1 = {http://www.springerlink.com/content/978-1-84882-934-3},
    doi = {10.1007/978-1-84882-935-0},
    isbn = {978-1-84882-934-3},
    keywords = {book, image-analysis, review},
    posted-at = {2014-02-19 12:23:05},
    priority = {2},
    publisher = {Springer London},
    title = {{Computer Vision}},
    url = {http://dx.doi.org/10.1007/978-1-84882-935-0},
    year = {2011}
}

@inproceedings{Bolosky1993False,
    abstract = {{False sharing occurs when processors in a shared-memory parallel system make references to different data objects within the same coherence block (cache line or page), thereby inducing \&quot;unnecessary\&quot; coherence operations. False sharing is widely believed to be a serious problem for parallel program performance, but a precise definition and quantification of the problem has proven to be elusive. We explain why. In the process, we present a variety of possible definitions for false sharing, and...}},
    author = {Bolosky, William J. and Scott, Michael L.},
    booktitle = {Proceedings of the USENIX SEDMS IV Conference},
    citeulike-article-id = {2792244},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.3255},
    keywords = {parallel-programming, performance},
    posted-at = {2014-02-19 11:03:24},
    priority = {3},
    title = {{False Sharing and its Effect on Shared Memory Performance}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.3255},
    year = {1993}
}

@article{Salembier1998Antiextensive,
    abstract = {{
                This paper deals with a class of morphological operators called connected operators. These operators filter the signal by merging its flat zones. As a result, they do not create any new contours and are very attractive for filtering tasks where the contour information has to be preserved. This paper shows that connected operators work implicitly on a structured representation of the image made of flat zones. The max-tree is proposed as a suitable and efficient structure to deal with the processing steps involved in antiextensive connected operators. A formal definition of the various processing steps involved in the operator is proposed and, as a result, several lines of generalization are developed. First, the notion of connectivity and its definition are analyzed. Several modifications of the traditional approach are presented. They lead to connected operators that are able to deal with texture. They also allow the definition of connected operators with less leakage than the classical ones. Second, a set of simplification criteria are proposed and discussed. They lead to simplicity-, entropy-, and motion-oriented operators. The problem of using a nonincreasing criterion is analyzed. Its solution is formulated as an optimization problem that can be very efficiently solved by a Viterbi algorithm. Finally, several implementation issues are discussed showing that these operators can be very efficiently implemented.
            }},
    author = {Salembier, P. and Oliveras, A. and Garrido, L.},
    citeulike-article-id = {9636934},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/83.663500},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=663500},
    citeulike-linkout-2 = {http://view.ncbi.nlm.nih.gov/pubmed/18276273},
    citeulike-linkout-3 = {http://www.hubmed.org/display.cgi?uids=18276273},
    doi = {10.1109/83.663500},
    institution = {E.T.S.E.T.B., Univ. Politecnica de Catalunya, Barcelona},
    issn = {1057-7149},
    journal = {IEEE transactions on image processing : a publication of the IEEE Signal Processing Society},
    keywords = {algorithms, morphology},
    month = apr,
    number = {4},
    pages = {555--570},
    pmid = {18276273},
    posted-at = {2014-02-17 14:59:07},
    priority = {2},
    publisher = {IEEE},
    title = {{Antiextensive connected operators for image and sequence processing.}},
    url = {http://dx.doi.org/10.1109/83.663500},
    volume = {7},
    year = {1998}
}

@misc{MadduriGTgraph,
    author = {Madduri, Kamesh and Bade, David A.},
    citeulike-article-id = {13037418},
    citeulike-linkout-0 = {https://github.com/dhruvbird/GTgraph},
    keywords = {algorithms, graphs, website},
    note = {Accessed: 12.02.2014},
    posted-at = {2014-02-12 10:44:04},
    priority = {0},
    title = {{GTgraph: A suite of synthetic graph generators}},
    url = {https://github.com/dhruvbird/GTgraph}
}

@article{Shavit1997Software,
    abstract = {{As we learn from the literature, flexibility in choosing synchronization operations greatly simplifies the task of designing highly concurrent programs. Unfortunately, existing hardware is inflexible and is at best on the level of a Load–Linked/Store–Conditional operation on a single word. Building on the hardware based transactional synchronization methodology of Herlihy and Moss, we offer software transactional memory (STM), a novel software method for supporting flexible transactional programming of synchronization operations. STM is non-blocking, and can be implemented on existing machines using only a Load–Linked/Store–Conditional operation. We use STM to provide a general highly concurrent method for translating sequential object implementations to non-blocking ones based on implementing a k-word compare\&swap STM-transaction. Empirical evidence collected on simulated multiprocessor architectures shows that our method always outperforms the non-blocking translation methods in the style of Barnes, and outperforms Herlihy's translation method for sufficiently large numbers of processors. The key to the efficiency of our software-transactional approach is that unlike Barnes style methods, it is not based on a costly  ” recursive helping” policy.}},
    author = {Shavit, Nir and Touitou, Dan},
    booktitle = {Distributed Computing},
    citeulike-article-id = {2056039},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/s004460050028},
    citeulike-linkout-1 = {http://link.springer.com/article/10.1007/s004460050028},
    day = {22},
    doi = {10.1007/s004460050028},
    journal = {Distributed Computing},
    keywords = {parallel-programming, stm},
    month = feb,
    number = {2},
    pages = {99--116},
    posted-at = {2014-02-11 12:12:26},
    priority = {2},
    publisher = {Springer-Verlag},
    title = {{Software transactional memory}},
    url = {http://dx.doi.org/10.1007/s004460050028},
    volume = {10},
    year = {1997}
}

@article{Erdos1959Random,
    author = {Erd\"{o}s, P. and R\'{e}nyi, A.},
    citeulike-article-id = {1282814},
    citeulike-linkout-0 = {http://www.renyi.hu/\~{}p_erdos/1959-11.pdf},
    journal = {Publicationes Mathematicae},
    keywords = {graphs, random},
    pages = {290--297},
    posted-at = {2014-02-02 14:58:09},
    priority = {2},
    title = {{On Random Graphs, I}},
    url = {http://www.renyi.hu/\~p_erdos/1959-11.pdf},
    volume = {6},
    year = {1959}
}

@article{Sutter2005Free,
    author = {Sutter, Herb},
    citeulike-article-id = {12941114},
    howpublished = {http://www.gotw.ca/publications/concurrency-ddj.htm},
    journal = {Dr. Dobb's Journal},
    keywords = {parallel-programming, review},
    month = mar,
    number = {3},
    posted-at = {2014-01-29 15:01:02},
    priority = {3},
    title = {{The free lunch is over: a fundamental turn toward concurrency in software.}},
    volume = {30},
    year = {2005}
}

@misc{AmdOpteronSpecsWebsite,
    citeulike-article-id = {12941069},
    citeulike-linkout-0 = {http://products.amd.com/pages/OpteronCPUDetail.aspx?id=814},
    keywords = {technical-details, website},
    note = {Accessed: 28.01.2014},
    posted-at = {2014-01-29 14:12:55},
    priority = {0},
    title = {{AMD Opteron (TM) Processor Solutions}},
    url = {http://products.amd.com/pages/OpteronCPUDetail.aspx?id=814}
}

@misc{MultiverseWebsite,
    citeulike-article-id = {12941067},
    citeulike-linkout-0 = {http://multiverse.codehaus.org},
    keywords = {parallel-programming, stm, website},
    note = {Accessed: 29.01.2014},
    posted-at = {2014-01-29 14:07:48},
    priority = {0},
    title = {{Software Transactional Memory for Java \& the JVM}},
    url = {http://multiverse.codehaus.org}
}

@phdthesis{Nethercote2004Dynamic,
    abstract = {{This dissertation describes Valgrind in some detail (some of these details are now out-of-date) as well as Cachegrind, Annelid and Redux; it also covers some underlying theory about dynamic binary analysis in general and what all these tools have in common. Please cite it if you are writing about Cachegrind, or the dynamic binary analysis theory work. If you are writing about Valgrind in general, please cite the PLDI2007 paper above in preference. If you are writing about Annelid, please cite the SPACE2004 paper in preference. If you are writing about Redux, please cite the ENTCS paper in preference.}},
    author = {Nethercote, Nicholas},
    citeulike-article-id = {12940265},
    keywords = {cachegrind, instrumentation, performance},
    month = nov,
    posted-at = {2014-01-28 15:23:53},
    priority = {2},
    school = {University of Cambridge},
    title = {{Dynamic Binary Analysis and Instrumentation}},
    year = {2004}
}

@inproceedings{Michael1996Simple,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Michael, Maged M. and Scott, Michael L.},
    booktitle = {Proceedings of the fifteenth annual ACM symposium on Principles of distributed computing},
    citeulike-article-id = {4448},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=248106},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/248052.248106},
    doi = {10.1145/248052.248106},
    isbn = {0-89791-800-2},
    keywords = {algorithms, parallel-programming},
    location = {Philadelphia, Pennsylvania, USA},
    pages = {267--275},
    posted-at = {2014-01-08 09:07:28},
    priority = {0},
    publisher = {ACM},
    series = {PODC '96},
    title = {{Simple, fast, and practical non-blocking and blocking concurrent queue algorithms}},
    url = {http://dx.doi.org/10.1145/248052.248106},
    year = {1996}
}

@book{Herlihy2008Art,
    abstract = {{Multiprocessor programming, also known as multicore programming, requires new principles, algorithms, and programming tools. This book provides a comprehensive presentation of the principles and tools available for programming multiprocessor machines. It will be of immediate use to programmers working with the new architectures.}},
    author = {Herlihy, Maurice and Shavit, Nir},
    citeulike-article-id = {10675355},
    citeulike-linkout-0 = {http://www.worldcat.org/isbn/9780123705914},
    citeulike-linkout-1 = {http://books.google.com/books?vid=ISBN9780123705914},
    citeulike-linkout-2 = {http://www.amazon.com/gp/search?keywords=9780123705914\&index=books\&linkCode=qs},
    citeulike-linkout-3 = {http://www.librarything.com/isbn/9780123705914},
    citeulike-linkout-4 = {http://www.worldcat.org/oclc/776069297},
    isbn = {9780123705914},
    keywords = {algorithms, book, parallel-programming},
    posted-at = {2014-01-07 12:55:21},
    priority = {3},
    publisher = {Elsevier/Morgan Kaufmann},
    title = {{The art of multiprocessor programming}},
    url = {http://www.worldcat.org/isbn/9780123705914},
    year = {2008}
}

@book{Goetz2006Java,
    author = {Goetz, Brian and Peierls, Tim and Bloch, Joshua and Bowbeer, Joseph and Holmes, David and Lea, Doug},
    citeulike-article-id = {1030084},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321349601},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0321349601},
    citeulike-linkout-10 = {http://www.worldcat.org/oclc/846089284},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0321349601},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0321349601},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0321349601/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321349601},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0321349601},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0321349601},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0321349601\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0321349601},
    day = {19},
    edition = {1},
    howpublished = {Paperback},
    isbn = {0321349601},
    keywords = {book, parallel-programming},
    month = may,
    posted-at = {2013-12-16 22:08:02},
    priority = {3},
    publisher = {Addison-Wesley Professional},
    title = {{Java Concurrency in Practice}},
    url = {http://www.worldcat.org/isbn/0321349601},
    year = {2006}
}

@mastersthesis{Berman2010Multicore,
    abstract = {{A crucial question facing today's multicore programmers is which programming methodology to use for coordination and data structure design: fine grained locking, lock-free or wait-free synchronization, or perhaps transactional memory. One aspect of this question that has received little attention is the tradeoff between performance and flexibility. In other words, given a data structure implemented using methodology X, delivering a given level of scalability, how costly is it, in terms of both  performance and ease of programming, to use
methodology X to add new features to this existing algorithm.

This work studies the flexibility question in the context of the union-find
problem, a problem that is a unique fit for our quest in that it has a known efficient wait-free concurrent solution for implementing the union and find methods, but only a complex sequential solution if one wishes to allow delete methods.

Based on union find, we are able to make interesting observations about the
relative benefits of using locks, non-blocking algorithms, and state-of-the-art software transactional memory systems. Moreover, based on our new understandings, we present highly efficient and flexible algorithms for the union-find and union-find-delete problems that we believe are of independent interest.}},
    address = {Schreiber Building, Tel Aviv University, P.O.B. 39040, Ramat Aviv, Tel Aviv 69978},
    author = {Berman, Igor},
    citeulike-article-id = {12810835},
    citeulike-linkout-0 = {http://mcg.cs.tau.ac.il/papers/igor-berman-msc.pdf},
    keywords = {algorithms, parallel-programming, union-find},
    month = jul,
    posted-at = {2013-12-03 10:16:58},
    priority = {5},
    school = {Tel-Aviv University, School of Computer Science},
    title = {{Multicore Programming in the Face of Metamorphosis: Union-Find as an Example}},
    url = {http://mcg.cs.tau.ac.il/papers/igor-berman-msc.pdf},
    year = {2010}
}

@article{Serra1992Overview,
    abstract = {{This paper consists of a tutorial overview of morphological filtering, a theory introduced in 1988 in the context of mathematical morphology. Its first section is devoted to the presentation of the lattice framework. Emphasis is put on the lattices of numerical functions in digital and continuous spaces. The basic filters, namely the openings and the closings, are then described and their various versions are listed. In the third section morphological filters are defined as increasing idempotent operators, and their laws of composition are proved. The last sections are concerned with two special classes of filters and their derivations: first, the alternating sequential filters allow us to bring into play families of operators depending on a positive scale parameter. Finally, the center and the toggle mappings modify the function under study by comparing it, at each point, with a few reference transforms.}},
    author = {Serra, Jean and Vincent, Luc},
    booktitle = {Circuits, Systems and Signal Processing},
    citeulike-article-id = {3377121},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/bf01189221},
    citeulike-linkout-1 = {http://link.springer.com/article/10.1007/BF01189221},
    day = {1},
    doi = {10.1007/bf01189221},
    journal = {Circuits, Systems, and Signal Processing},
    keywords = {morphology, review},
    month = mar,
    number = {1},
    pages = {47--108},
    posted-at = {2013-11-25 11:00:45},
    priority = {0},
    publisher = {Birkh\"{a}user-Verlag},
    title = {{An overview of morphological filtering}},
    url = {http://dx.doi.org/10.1007/bf01189221},
    volume = {11},
    year = {1992}
}

@book{Tarjan1983Data,
    author = {Tarjan, Robert E.},
    citeulike-article-id = {12799896},
    citeulike-linkout-0 = {http://www.worldcat.org/isbn/9780898711875},
    citeulike-linkout-1 = {http://books.google.com/books?vid=ISBN9780898711875},
    citeulike-linkout-2 = {http://www.amazon.com/gp/search?keywords=9780898711875\&index=books\&linkCode=qs},
    citeulike-linkout-3 = {http://www.librarything.com/isbn/9780898711875},
    citeulike-linkout-4 = {http://www.worldcat.org/oclc/848042077},
    isbn = {9780898711875},
    keywords = {algorithms, book, union-find},
    location = {Philadelphia, PA},
    posted-at = {2013-11-25 10:50:22},
    priority = {2},
    publisher = {Society For Industrial And Applied Mathematics},
    title = {{Data structures and network algorithms}},
    url = {http://www.worldcat.org/isbn/9780898711875},
    year = {1983}
}

@inproceedings{Manne2010Scalable,
    abstract = {{The Union-Find algorithm is used for maintaining a number of non-overlapping sets from a finite universe of elements. The algorithm has applications in a number of areas including the computation of spanning trees, sparse linear algebra, and in image processing. Although the algorithm is inherently sequential there has been some previous efforts at constructing parallel implementations. These have mainly focused on shared memory computers. In this paper we present the first scalable parallel implementation of the Union-Find algorithm suitable for distributed memory computers. Our new parallel algorithm is based on an observation of how the Find part of the sequential algorithm can be executed more efficiently. We show the efficiency of our implementation through a series of tests to compute spanning forests of very large graphs.}},
    address = {Berlin, Heidelberg},
    author = {Manne, Fredrik and Md},
    booktitle = {Proceedings of the 8th International Conference on Parallel Processing and Applied Mathematics: Part I},
    citeulike-article-id = {12793006},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1882815},
    isbn = {3-642-14389-X, 978-3-642-14389-2},
    keywords = {algorithms, parallel-programming, union-find},
    location = {Wroclaw, Poland},
    pages = {186--195},
    posted-at = {2013-11-18 18:08:04},
    priority = {3},
    publisher = {Springer-Verlag},
    series = {PPAM'09},
    title = {{A Scalable Parallel Union-find Algorithm for Distributed Memory Computers}},
    url = {http://portal.acm.org/citation.cfm?id=1882815},
    year = {2010}
}

@inproceedings{Gabow1983Lineartime,
    abstract = {{This paper presents a linear-time algorithm for the special case of the disjoint set union problem in which the structure of the unions (defined by a  ” union tree”) is known in advance. The algorithm executes an intermixed sequence of m union and find operations on n elements in 0(m+n) time and 0(n) space. This is a slight but theoretically significant improvement over the fastest known algorithm for the general problem, which runs in 0(m\&agr;(m+n, n)+n) time and 0(n) space, where \&agr; is a functional inverse of Ackermann's function. Used as a subroutine, the algorithm gives similar improvements in the efficiency of algorithms for solving a number of other problems, including two-processor scheduling, the off-line min problem, matching on convex graphs, finding nearest common ancestors off-line, testing a flow graph for reducibility, and finding two disjoint directed spanning trees. The algorithm obtains its efficiency by combining a fast algorithm for the general problem with table look-up on small sets, and requires a random access machine for its implementation. The algorithm extends to the case in which single-node additions to the union tree are allowed. The extended algorithm is useful in finding maximum cardinality matchings on nonbipartite graphs.}},
    address = {New York, NY, USA},
    author = {Gabow, Harold N. and Tarjan, Robert E.},
    booktitle = {Proceedings of the Fifteenth Annual ACM Symposium on Theory of Computing},
    citeulike-article-id = {3358358},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=808753},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/800061.808753},
    doi = {10.1145/800061.808753},
    isbn = {0-89791-099-0},
    keywords = {algorithms, union-find},
    pages = {246--251},
    posted-at = {2013-11-18 18:06:34},
    priority = {4},
    publisher = {ACM},
    series = {STOC '83},
    title = {{A Linear-time Algorithm for a Special Case of Disjoint Set Union}},
    url = {http://dx.doi.org/10.1145/800061.808753},
    year = {1983}
}

@inproceedings{Fruhwirth2005Parallelizing,
    abstract = {{Constraint Handling Rules is a logical concurrent committed-choice rule-based language. Recently it was shown that the classical union-find algorithm can be implemented in CHR with optimal time complexity. Here we investigate if a parallel implementation of this algorithm is also possible in CHR. The problem is hard for several reasons: - Up to now, no parallel computation model for CHR was defined. - Tarjan's optimal union-find is known to be hard to parallelize. - The parallel code should be as close as possible to the sequential one. It turns out that confluence analysis of the sequential implementation gives almost all the information needed to parallelize the union-find algorithm under a rather general parallel computation model for CHR.}},
    address = {Berlin, Heidelberg},
    author = {Fr\"{u}hwirth, Thom},
    booktitle = {Proceedings of the 21st International Conference on Logic Programming},
    citeulike-article-id = {12793001},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2079636},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/11562931_11},
    doi = {10.1007/11562931_11},
    isbn = {3-540-29208-X, 978-3-540-29208-1},
    keywords = {algorithms, parallel-programming},
    location = {Sitges, Spain},
    pages = {113--127},
    posted-at = {2013-11-18 18:03:56},
    priority = {3},
    publisher = {Springer-Verlag},
    series = {ICLP'05},
    title = {{Parallelizing Union-find in Constraint Handling Rules Using Confluence Analysis}},
    url = {http://dx.doi.org/10.1007/11562931_11},
    year = {2005}
}

@inproceedings{Groves2008Verifying,
    abstract = {{Lock-free algorithms have been developed to avoid various problems associated with using locks to control access to shared data structures. These algorithms are typically more intricate than lock-based algorithms, as they allow more complex interactions between processes, and many published algorithms have turned out to contain errors. There is thus a pressing need for practical techniques for verifying lock-free algorithms and programs that use them. In this paper we show how Michael and Scott's well known lock-free queue algorithm can be verified using a trace reduction method, based on Lipton's reduction method. Michael and Scott's queue is an interesting case study because, although the basic idea is easy to understand, the actual algorithm is quite subtle, and it demonstrates several way in which the basic reduction method needs to be extended.}},
    address = {Darlinghurst, Australia, Australia},
    author = {Groves, Lindsay},
    booktitle = {Proceedings of the Fourteenth Symposium on Computing: The Australasian Theory - Volume 77},
    citeulike-article-id = {12787822},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1379385},
    isbn = {978-1-920682-58-3},
    keywords = {algorithms, concurrency-verification, parallel-programming},
    location = {Wollongong, NSW, Australia},
    pages = {133--142},
    posted-at = {2013-11-13 21:12:26},
    priority = {3},
    publisher = {Australian Computer Society, Inc.},
    series = {CATS '08},
    title = {{Verifying Michael and Scott's Lock-free Queue Algorithm Using Trace Reduction}},
    url = {http://portal.acm.org/citation.cfm?id=1379385},
    year = {2008}
}

@article{Vafeiadis2008Modular,
    abstract = {{Traditionally, concurrent data structures are protected by a single mutual exclusion lock so that only one thread may access the data structure at any time. This coarse-grained approach makes it relatively easy to reason about correctness, but it severely limits parallelism. More advanced algorithms instead perform synchronisation at a finer grain. They employ sophisticated synchronisation schemes (both blocking and non-blocking) and are usually written in low-level languages such as C. This dissertation addresses the formal verification of such algorithms. It proposes techniques that are modular (and hence scalable), easy for programmers to use, and yet powerful enough to verify complex algorithms. In doing so, it makes two theoretical and two practical contributions to reasoning about fine-grained concurrency. First, building on rely/guarantee reasoning and separation logic, it develops a new logic, RGSep, that subsumes these two logics and enables simple, modular proofs of finegrained concurrent algorithms that use complex dynamically allocated data structures and may explicitly deallocate memory. RGSep allows for ownership-based reasoning and ownership}},
    author = {Vafeiadis, Viktor},
    citeulike-article-id = {12787818},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.145.9530},
    keywords = {concurrency-verification, parallel-programming},
    posted-at = {2013-11-13 21:09:22},
    priority = {3},
    title = {{Modular fine-grained concurrency verification}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.145.9530},
    year = {2008}
}

@article{Kogan2012Methodology,
    abstract = {{Lock-freedom is a progress guarantee that ensures overall program progress. Wait-freedom is a stronger progress guarantee that ensures the progress of each thread in the program. While many practical lock-free algorithms exist, wait-free algorithms are typically inefficient and hardly used in practice. In this paper, we propose a methodology called fast-path-slow-path for creating efficient wait-free algorithms. The idea is to execute the efficient lock-free version most of the time and revert to the wait-free version only when things go wrong. The generality and effectiveness of this methodology is demonstrated by two examples. In this paper, we apply this idea to a recent construction of a wait-free queue, bringing the wait-free implementation to perform in practice as efficient as the lock-free implementation. In another work, the fast-path-slow-path methodology has been used for (dramatically) improving the performance of a wait-free linked-list.}},
    address = {New York, NY, USA},
    author = {Kogan, Alex and Petrank, Erez},
    citeulike-article-id = {12739472},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2145816.2145835},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2370036.2145835},
    doi = {10.1145/2370036.2145835},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {parallel-programming},
    month = feb,
    number = {8},
    pages = {141--150},
    posted-at = {2013-11-12 08:35:16},
    priority = {3},
    publisher = {ACM},
    title = {{A methodology for creating fast wait-free data structures}},
    url = {http://dx.doi.org/10.1145/2370036.2145835},
    volume = {47},
    year = {2012}
}

@article{Gabow1985Lineartime,
    abstract = {{This paper presents a linear-time algorithm for the special case of the disjoint set union problem in which the structure of the unions (defined by a  ” union tree”) is known in advance. The algorithm executes an intermixed sequence of m union and find operations on n elements in  O ( m + n ) time and  O ( n ) space. This is a slight but theoretically significant improvement over the fastest known algorithm for the general problem, which runs in  O ( m α( m + n ,  n )+ n ) time and  O ( n ) space, where a is a functional inverse of Ackermann's function. Used as a subroutine, the algorithm gives similar improvements in the efficiency of algorithms for solving several other problems, including two-processor scheduling, matching on convex graphs, finding nearest common ancestors off-line, testing a flow graph for reducibility, and finding two disjoint directed spanning trees. The algorithm obtains its efficiency by combining the fast algorithm for the general problem with table look-up on small sets, and requires a random access machine for its implementation. The algorithm extends to the case in which single-node additions to the union tree are allowed. The extended algorithm is useful in finding maximum cardinality matchings in nonbipartite graphs.}},
    author = {Gabow, Harold N. and Tarjan, Robert E.},
    citeulike-article-id = {4039208},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/0022-0000(85)90014-5},
    doi = {10.1016/0022-0000(85)90014-5},
    issn = {00220000},
    journal = {Journal of Computer and System Sciences},
    keywords = {algorithms},
    month = apr,
    number = {2},
    pages = {209--221},
    posted-at = {2013-11-11 16:32:38},
    priority = {2},
    title = {{A linear-time algorithm for a special case of disjoint set union}},
    url = {http://dx.doi.org/10.1016/0022-0000(85)90014-5},
    volume = {30},
    year = {1985}
}

@article{Wilkinson2008Concurrent,
    author = {Wilkinson, M. H. F. and Gao, Hui and Hesselink, W. H. and Jonker, J. E. and Meijster, A.},
    citeulike-article-id = {12754964},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/tpami.2007.70836},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4407727},
    doi = {10.1109/tpami.2007.70836},
    institution = {Inst. for Math. \& Comput. Sci., Univ. of Groningen, Groningen},
    issn = {0162-8828},
    journal = {Pattern Analysis and Machine Intelligence, IEEE Transactions on},
    keywords = {morphology, parallel-programming, performance},
    month = oct,
    number = {10},
    pages = {1800--1813},
    posted-at = {2013-11-05 09:12:45},
    priority = {3},
    publisher = {IEEE},
    title = {{Concurrent Computation of Attribute Filters on Shared Memory Parallel Machines}},
    url = {http://dx.doi.org/10.1109/tpami.2007.70836},
    volume = {30},
    year = {2008}
}

@article{Breen1996Attribute,
    abstract = {{In this paper we establish an attribute-based approach to openings and closings and provide an efficient algorithm for their implementation on gray-scale images. Attribute openings are similar to openings by reconstruction since they are connected component transformations. However, attribute openings are more general because they can describe generalized shape features and openings that have no shape-bias. This work is then extended to gray-scale granuolmetries and to include gray-scale thinnings, which are nonincreasing filters. The use of nonincreasing gray-scale thinnings is seen as an important generalization because it allows the use of nonincreasing shape descriptors such as compactness and eccentricity to be applied to filter gray-scale images. Applications are then given to illustrate the performance of the filters proposed.}},
    author = {Breen, Edmond J. and Jones, Ronald},
    citeulike-article-id = {12628362},
    citeulike-linkout-0 = {http://www.sciencedirect.com/science/article/pii/S1077314296900661\#},
    citeulike-linkout-1 = {http://dx.doi.org/10.1006/cviu.1996.0066},
    doi = {10.1006/cviu.1996.0066},
    issn = {10773142},
    journal = {Computer Vision and Image Understanding},
    keywords = {granulometry, morphology},
    month = nov,
    number = {3},
    pages = {377--389},
    posted-at = {2013-11-05 09:11:32},
    priority = {0},
    title = {{Attribute Openings, Thinnings, and Granulometries}},
    url = {http://www.sciencedirect.com/science/article/pii/S1077314296900661\#},
    volume = {64},
    year = {1996}
}

@incollection{Hernandez2009Ultimate,
    abstract = {{In this paper, a method for morphological segmentation using shape information is presented. This method is based on a morphological operator named ultimate attribute opening (UAO). Our approach considers shape information to favor the detection of specific shapes. The method is validated in the framework of two applications: fa\c{c}ade analysis and scene-text detection. The experimental results show that our approach is more robust than the standard UAO.}},
    author = {Hern\'{a}ndez, Jorge and Marcotegui, Beatriz},
    booktitle = {Mathematical Morphology and Its Application to Signal and Image Processing},
    citeulike-article-id = {12700571},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-03613-2_19},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-03613-2_19},
    doi = {10.1007/978-3-642-03613-2_19},
    editor = {Wilkinson, MichaelH and Roerdink, JosB},
    keywords = {algorithms, computer-vision, morphology, segmentation},
    pages = {205--214},
    posted-at = {2013-11-05 09:11:20},
    priority = {5},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Ultimate Attribute Opening Segmentation with Shape Information}},
    url = {http://dx.doi.org/10.1007/978-3-642-03613-2_19},
    volume = {5720},
    year = {2009}
}

@incollection{Vincent1994Morphological,
    abstract = {{The filter that removes from a binary image the components with area smaller than a parameter λ is called area opening. Together with its dual, the area closing, it is first extended to grey-scale images. It is then proved to be equivalent to a maximum of morphological openings with all the connected structuring elements of area greater than or equal to λ. The study of the relationships between these filters and image extrema leads to a very efficient area opening/closing algorithm. Grey-scale area openings and closings can be seen as transformations with a structuring element which locally adapts its shape to the image structures, and therefore have very nice filtering capabilities. Their effect is compared to that of more standard morphological filters. Some applications in image segmentation and hierarchical decomposition are also briefly described.}},
    author = {Vincent, Luc},
    booktitle = {Shape in Picture},
    citeulike-article-id = {12556147},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-662-03039-4_13},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-662-03039-4_13},
    doi = {10.1007/978-3-662-03039-4_13},
    editor = {Ying-Lie and Toet, Alexander and Foster, David and Heijmans, HenkJ and Meer, Peter},
    keywords = {algorithms, morphology},
    pages = {197--208},
    posted-at = {2013-11-05 09:11:03},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {NATO ASI Series},
    title = {{Morphological Area Openings and Closings for Grey-scale Images}},
    url = {http://dx.doi.org/10.1007/978-3-662-03039-4_13},
    volume = {126},
    year = {1994}
}

@inproceedings{Wilkinson2000Fast,
    abstract = {{Morphological attribute openings and closings and related operators are generalizations of the area opening and closing, and allow filtering of images based on a wide variety of shape or size based criteria. A fast union-find algorithm for the computation of these operators is presented in this paper. The new algorithm has a worst case time complexity of O(N log N) where N is the image size, as opposed to O(N log N) for the existing algorithm. Memory requirements are O(N) for both algorithms.}},
    author = {Wilkinson, Michael H. F. and Roerdink, Jos B. T. M.},
    booktitle = {In Proceedings of the ISMM2000},
    citeulike-article-id = {12681694},
    citeulike-linkout-0 = {http://www.cs.rug.nl/\~{}michael/ismm2000.pdf},
    citeulike-linkout-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.2632},
    keywords = {algorithms, granulometry, morphology, performance},
    pages = {311--320},
    posted-at = {2013-11-05 09:09:57},
    priority = {0},
    title = {{Fast Morphological Attribute Operations Using Tarjan's Union-Find Algorithm}},
    url = {http://www.cs.rug.nl/\~michael/ismm2000.pdf},
    year = {2000}
}

@inproceedings{Anderson1994Waitfree,
    abstract = {{We are interested in designing efficient data structures for a shared memory multiprocessor. In this paper we focus on the Union-Find data structure. We consider a fully asynchronous model of computation where arbitrary delays are possible. Thus we require our solutions to the data structure problem have the wait-free property, meaning that each thread continues to make progress on its operations, independent of the speeds of the other threads. In this model efficiency is best measured in terms of the total number of instructions used to perform a sequence of data structure operations, the work performed by the processors. We give a wait-free implementation of an efficient algorithm for Union-Find. In addition we show that the worst case performance of the algorithm can be improved by simulating a synchronized algorithm, or by simulating a larger machine if the data structure requests support sufficient parallelism. Our solutions apply to a much more general adversary model than has be...}},
    author = {Anderson, Richard J. and Woll, Heather},
    booktitle = {In Proc. 23rd ACM Symposium on Theory of Computing},
    citeulike-article-id = {8423759},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.8354},
    keywords = {algorithms, parallel-programming},
    pages = {370--380},
    posted-at = {2013-11-05 09:09:42},
    priority = {5},
    title = {{Wait-free Parallel Algorithms for the Union-Find Problem}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.8354},
    year = {1994}
}

@inproceedings{Meijster2001Fast,
    author = {Meijster, A. and Wilkinson, M. H. F.},
    booktitle = {Image Processing, 2001. Proceedings. 2001 International Conference on},
    citeulike-article-id = {12601318},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/icip.2001.958207},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=958207},
    doi = {10.1109/icip.2001.958207},
    institution = {Centre for High Performance Comput., Groningen Univ., Netherlands},
    isbn = {0-7803-6725-1},
    keywords = {algorithms, granulometry, morphology},
    pages = {668--671 vol.3},
    posted-at = {2013-11-05 09:09:09},
    priority = {0},
    publisher = {IEEE},
    title = {{Fast computation of morphological area pattern spectra}},
    url = {http://dx.doi.org/10.1109/icip.2001.958207},
    volume = {3},
    year = {2001}
}

@article{Meijster2002Comparison,
    author = {Meijster, A. and Wilkinson, M. H. F.},
    citeulike-article-id = {12602537},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/34.993556},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=993556},
    doi = {10.1109/34.993556},
    institution = {Centre for High Performance Comput. \& Visualization, Groningen Univ., Netherlands},
    issn = {0162-8828},
    journal = {Pattern Analysis and Machine Intelligence, IEEE Transactions on},
    keywords = {algorithms, granulometry, morphology, parallel-programming, performance},
    month = apr,
    number = {4},
    pages = {484--494},
    posted-at = {2013-11-05 09:08:33},
    priority = {0},
    publisher = {IEEE},
    title = {{A comparison of algorithms for connected set openings and closings}},
    url = {http://dx.doi.org/10.1109/34.993556},
    volume = {24},
    year = {2002}
}
